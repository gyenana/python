# chapter8. 흘러가는 데이터 

> 데이터를 이해하기 전에 이론화하는 것은 큰 실수다 - 아서코난도일

- 활성화된 프로그램은 데이터를 램에 저장, 램은 아주 빠르지만 비싸고, 일정한 전력 공급을 필요로 함
- 프로그래머는 디스크와 같은 비휘발성 장치를 사용하여 데이터를 저장하고 복구할 수 있는 지속성이 필요하다.

### 8.1 파일 입출력

- 데이터를 가장 간단하게 지속하려면 '파일' 사용 → 이것을 플랫 파일 이라고 부르기도 함
- 파일은 단지 파일 이름으로 저장된 바이트 시퀀스
- **파일로 부터 데이터를 읽어서 메모리에 적재하고, 메모리에서 파일로 데이터를 씀** → 파이썬은 이러한 작업을 쉽게 할 수 있게 만들어줌
- 파일을 열려면 open() 함수를 사용해야 함

        fileobj = open(filename,mode) 
        
        # fileobj 는 open() 에 의해 반환되는 파일 객체 
        # filename 은 파일의 문자열 이름 
        # mode 는 파일 타입과 파일로 무엇을 할 지 명시하는 문자열 
        	# mode 는 두개의 인자를 사용 
        	# 첫번째 인자는 '작업' 을 명시
        	   # r : 파일 읽기 
        		 # w : 파일이 존재하면 덮쓰,존재안하면 파일생성
        		 # x : 파일이 존재하지 않을 경우에만 파일 쓰기 
        		 # a : 파일 추가하기 (파일 존재 시 파일 끝에서부터 씀) 
        	# 두번째 인자는 파일 타입을 명시 -> b: 이진타입 ,t (혹은 아무것도 명시 ㄴㄴ) : 텍스트 타입 

- 파일을 열고 다 사용했다면 **파일을 닫아야 함**

**8.1.1 텍스트 파일 쓰기 : write()** 

- write() 함수는 파일에 쓴 바이트 수를 반환, print() 함수처럼 스페이스나 줄바꿈을 추가하지 않는다.
    - 기본적으로 print() 함수는 각 인자뒤에 스페이스를, 끝에 줄바꿈을 추가 → print() 를 write() 처럼 사용하려면 2가지 인자를 전달
        - sep : 구분자 / 기본값은 스페이스 (' ')
        - end : 문자열 끝 : 기본값은 줄바꿈 ('\n')
- 파일에 쓸 문자열이 크면 특정 단위로 나누어서 파일에 쓴다.

    fout = open('relativity','wt')
    size = len(poem) 
    offset = 0 
    chunk = 100 
    while True:
    	if offset > size : 
    		break
    	fout.write(poem[offset:offset+chunk])
    	offset+=chunk
    
    100
    50

- 만일 relativity 파일이 중요하다면 모드 x 를 사용하여 파일을 덮어쓰지 않도록 한다.
    - x : 파일이 존재하지 않을 때만 덮어쓰기 → 존재하면 덮어 씌우지 않는다

**8.1.2 텍스트 파일 읽기 : read() , readline() , readlines()** 

- **read()** : 인자없이 호출 시 한번에 전체 파일을 읽을 수 있음 , 단 아주 큰 파일을 이와 같이 읽을 때 메모리가 소비될 수 있으므로 조심해야 함
    - 이 함수는 한번에 얼마만큼 읽을 것인지 크기를 제한할 수 있음 ⇒ read(100) : 한번에 100문자 읽겠다. (최대 문자수를 인자로 입력)
- **readline()** : 파일을 라인단위로 읽을 수 있음
- 텍스트 파일을 가장 읽기 쉬운 방법은 → 이터레이터를 사용하는 것 , 이터레이터는 한번에 한 라인씩 반환한다.

        poem = ' '
        fin = open('relativity','rt')
        for line in fin : 
        	poem += line 
        
        fin.close()
        len(poem) => 150 

- **readlines()** : 한번에 모든 라인을 읽고 , 한 라인으로 된 문자열들의 리스트를 반환

**8.1.3 이진 파일 쓰기 : write()** 

- 모드에 b 를 포함시키면 파일을 이진모드로 연다. → 이 경우 문자열 대신 바이트를 읽고 쓸 수 있음
- write() 함수는 파일에 쓴 바이트 수를 반환→ 텍스트 파일처럼 특정 단위로 이진 데이터를 쓸 수 있음

**8.1.4 이진 파일 읽기 : read()** 

- 이진 파일을 읽는 것은 간단, 모드를 'rb' 로 하면 됨

**8.1.5 자동으로 파일 닫기 : with** 

- 열려있는 파일을 닫지 않았을 때, 파이썬은 이 파일이 더이상 참조되지 않다는 것을 확인한 뒤 파일을 닫음
- 이는 함수 안에 파일을 열어놓고 명시적으로 닫지 않더라도 함수가 끝날 때 자동으로 파일이 닫힌다는 것을 의미
- 그러나 오랫동안 작동하는 함수 혹은 메인 프로그램에 파일을 열어두었다면, 파일에 쓰는 것을 마치기 위해 명시적으로 파일을 닫아야 함
- 파이썬에는 파일을 여는것과 같은 일을 수행하는 '**콘텍스트 매니저**' 가 있음

    with open(파일명,파일모드) as 변수 :
    	변수.write(~~~ ) 
    
    #콘텍스트 매니저 코드 블록의 코드 한줄이 실행되고 나서 자동으로 파일을 닫아줌 

**8.1.6 파일 위치 찾기 : seek()** 

- 파일을 읽고 쓸 때, 파이썬은 파일에서 위치를 추적
- tell() : 파일의 시작으로부터의 현재 오프셋을 바이트 단위로 변환
- seek() : 함수는 다른 바이트 오프셋으로 위치를 이동할 수 있음 → 이 함수 이용 시, 마지막 바이트를 읽기 위해 처음부터 마지막까지 파일 전체를 읽지 않아도 됨
    - seek() 함수는 현재 오프셋을 반환
    - seek() 함수의 형식은 seek(offset, origin) 이며, 두번째 인자에 대한 설명은 아래와 같음
        - origin = 0 : 시작위치에서 offset 바이트 이동
        - origin = 1 : 현재 위치에서 offset 바이트 이동
        - origin = 2 : 마지막 위치에서 offset 바이트 이동
- 참고 : 파일 포인터
    - 파일 처음 열었을 때 파일의 맨처음이 파일 포인터의 위치 = tell()
- 이 함수들은 이진파일에서 위치를 이동할 때 아주 유용하게 쓰임, 텍스트 파일에도 이 함수를 쓸 수 있으나 아스키코드(한 문자당 1바이트) 가 아니라면 오프셋을 계산하기 힘들다. 텍스트 인코딩에 따라 다르지만 가장 인기있는 인코딩 (utf8) 은 한 문자당 여러 바이트를 사용한다.

### 8.2 구조화된 텍스트 파일

- 어떤 프로그램에서 데이터를 저장하고나 이를 다른 프로그램으로 보낼때, 구조화된 데이터가 필요
- 구조화된 텍스트 파일 형식은 아주 많지만, 대표적으로 아래와 같은 몇가지 형식이 존재
    - \t (탭) , 콤마 (,) , 수직바 (|) 와 같은 문자를 '구분자' 로 사용, 대표적으로 CSV
    - 태그를 < 와 > 로 둘러싼다. 대표적으로 XML, HTML
    - 구두점 사용, 대표적으로 JSON
    - 들여쓰기 사용 , 대표적으로 YAML
    - 프로그램 설정파일과 같은 여러가지 형식을 사용
- 이러한 구조화된 파일 형식은 적어도 하나의 파이썬 모듈로 읽고 쓸 수 있음

**8.2.1 CSV** 

- 구분된 파일은 스프레드 시트와 데이터 베이스의 데이터 교환 형식으로 자주 사용됨
- CSV는 수동으로 한번에 한 라인씩 읽어서 콤마로 구분된 필드를 분리할 수 있으나, 파일 구문 분석 시 더 복잡할 수있기 때문에 표준 csv 모듈을 사용하는 것이 좋다.

    * 어떤 것은 콤마대신 수직바 | 나 탭 \t 문자를 사용
    * 어떤 것은 이스케이프 시퀀스를 사용, 만일 필드 내에 구분자를 포함하고 있다면, 전체 필드는 인용 부호로 둘러싸여 있거나, 
      일부 이스케이프 문자가 앞에 올 수 있다. 
    * 파일은 운영체제에 따라 줄바꿈 문자가 다름 -> 유닉스는 \n , 마이크로소프트는 \r\n 애플은 \r 을 씀 
      단, 현재는 \n 을 사용 
    * 열 이름이 첫 번째 라인에 올 수 있다. 
    

- reader() : csv 형식의 파일을 쉽게 읽을 수 있음
- 기본값으로 reader() 와 write() 함수를 사용하면, 열은 콤마로 나누어지고, 행은 줄바꿈 문자로 나누어진다.
- DictReader() 함수 이용 시, 딕셔너리의 리스트로 데이터를 만들 수 있으며, 열 이름 지정할 수 있음
- DictWriter() 함수를 이용, CSV 파일을 다시 쓸 수 있으며, Csv 파일의 첫 라인에 열 이름을 쓰기 위해 writeheader() 함수 호출

    import csv 
    villains = [
    	['doctor','no'],
    	['rosa','klebb']
    	]
    
    #파일 쓰기 -> 파일 생성 
    with open('villains','wt') as fout:
    	csvout = csv.writer(fout)
    	csvout.writerows(villains) 
    
    >> 결과 
    doctor,no
    rosa,klebb 
    
    #파일 읽기 
    with open('villains','rt') as fin:
    	cin = csv.reader(fin)
    	villains = [row for row in cin] # 리스트 컴프리헨션 
    print(villains) 
    
    >>결과 
    [['doctor','no'],['rosa','klebb']]
    
    #딕셔너리의 리스트로 파일 읽기 
    with open('villains','rt') as fin:
    	cin = csv.DictReader(fin,fieldnames=['first','last']) #딕셔너리화 
    	villains = [row for row in cin] # 리스트 컴프리헨션 
    print(villains) 
    
    >>결과 
    [{'last':'no','first':'doctor'},
     {'last':'klebb','first':'rosa'}]
    
    #딕셔너리의 리스트로 파일 쓰기 
    villains = [{'last':'no','first':'doctor'},
     {'last':'klebb','first':'rosa'}]
    with open('villains','rt') as fout:
    	cout = csv.DictWriter(fout,['first','last']) #딕셔너리화 
    	cout.writeheader()
    	count.writerows(villains)
    
    >>결과 
    first,last
    doctor,no
    rosa,klebb
    

**8.2.2 XML** 

- 구분된 파일은 행(라인) 과 열 (라인에 속하는 필드) 의 2차원 구조로 구성되어 있음
    - 프로그램 간 자료 구조를 교환하기 위해 텍스트를 계층구조, 시퀀스, 셋 또는 다른 자료구조로 인코딩 해야한다.
- XML은 가장 잘 알려진 마크업 형식으로, 데이터를 구분하기 위해 '태그' 를 사용
- XML의 중요한 특징

        1. 태그는 < 문자로 시작 
        2. 공백은 무시 
        3. 일반적으로 시작태그 이후 다른 내용이 따라오며, 그 후 끝태그가 매칭됨 
        	< ~~ >  : 시작태그 / </~~> : 끝태그 
        4. 태그 안에 태그를 중첩할 수 있다. -> 중첩된 태그는 태그의 자식 
        5. 옵션 속성은 시작 태그에 나올 수 있다. 
        6. 태그는 값을 가질 수 있다. 
        7. 태그에 값이나 자식이 없다면 시작 태그와 끝태그가 아닌 <~~/> 라는 단일 태그로 표현될 수 있다. 
        8. 속성, 값, 자식태그의 데이터를 어디에 넣을 것인가에 대한 선택은 다소 임의적이다. 

- 참고
    - 마크업 언어란? : [https://ko.wikipedia.org/wiki/마크업_언어](https://ko.wikipedia.org/wiki/%EB%A7%88%ED%81%AC%EC%97%85_%EC%96%B8%EC%96%B4)
    - XML이란 ? : [https://ko.wikipedia.org/wiki/XML](https://ko.wikipedia.org/wiki/XML)
- xml은 데이터 피드와 메시지 전송에 많이 쓰임
- xml을 파싱하는 간단한 방법은 ElementTree 모듈을 사용하는 것
    - 중첩된 리스트의 각 요소에 대해 tag 는 태그 문자열이고, attrib는 속성의 딕셔너리
    - ElementTree 모듈은 xml 에서 파생된 데이터를 검색하고 수정할 수 있는 다양한 방법을 제공한다.
- 기타 표준 파이썬 xml 라이브러리
    - xml.dom : 전체 xml 파일을 메모리에 로딩, xml 의 모든 항목을 접근할 수 있게 함
    - xml.sax : 즉석에서 xml 을 파싱, 한번에 전체 xml 파일을 메모리에 로딩하지 않음 → 매우 큰 스트림 처리 시 이 모듈을 사용하면 좋음

**8.2.3 HTML** 

- 웹의 기본 문서 형식으로 엄청난 양의 데이터가 html 로 저장되어 있음
- 다만, 대부분의 html 파일의 경우 규칙을 따르지 않아서 파싱이 어려울 수 있음 + html의 대부분은 데이터를 교환한다기보다 결과를 표현하는 형태로 더 많이 사용

**8.2.4 JSON** 

- 제이슨은 자바 스크립트를 넘어서 데이터를 교환하는 아주 인기있는 형식이 됨 → 자바스크립트의 서브셋이자, 유효한 파이썬 구문임

    #json 형태 예시 
    
    {
        "1.FirstName": "Gildong",
        "2.LastName": "Hong",
        "3.Age": 20,
        "4.University": "Yonsei University",
        "5.Courses": [
            {
                "Classes": [
                    "Probability",
                    "Generalized Linear Model",
                    "Categorical Data Analysis"
                ],
                "Major": "Statistics"
            },
            {
                "Classes": [
                    "Data Structure",
                    "Programming",
                    "Algorithms"
                ],
                "Minor": "ComputerScience"
            }
        ]
    }
    
    출처: https://rfriend.tistory.com/474 [R, Python 분석과 프로그래밍의 친구 (by R Friend)]

- 프로그램 간에 데이터를 교환할 때, 파이썬과 제이슨은 궁합이 잘 맞음
- 다수의xml 모듈과는 달리, 제이슨에는 하나의 메인 모듈이 있음 → json
- json 모듈은 데이터를 제이슨 문자열로 인코딩 (dumps) 하고, 제이슨 문자열을 다시 데이터로 디코딩(loads) 할 수 있음
- 표준 제이슨 모듈에서 날짜 또는 시간 타입이 별도로 정의되어 있지 않기 때문에, datetime 객체의 경우 문자열과 에포치값과 같이 제이슨이 이해할 수 있는 값으로 변환해야 함
    - 에포치 : 1970년 1월 1일 00:00:00 협정 세계시(UTC) 부터의 경과 시간을 초로 환산하여 정수로 나타낸 것
- 자료구조에 대해 아무것도 모르는 상태에서, 제이슨과 다른 구조화된 텍스트 형식의 파일을 자료구조로 불러올 수 있음 , 그리고 isinstance() 와 타입에 적절한 메서드를 사용하여 구조를 파악한 후 값을 볼 수 있음
    - isinstance() : 객체가 datetime.datetime 클래스의 인스턴스인지 확인

**8.2.5 YAML** 

- [https://m.blog.naver.com/PostView.nhn?blogId=wideeyed&logNo=221090209367&proxyReferer=https%3A%2F%2Fwww.google.com%2F](https://m.blog.naver.com/PostView.nhn?blogId=wideeyed&logNo=221090209367&proxyReferer=https%3A%2F%2Fwww.google.com%2F)
- 제이슨과 유사하게 yaml은 키와 값을 가지고 있지만, 날짜와 시간같은 데이터 타입을 더 많이 처리함
- **표준 파이썬 라이브러리는 아직 yaml 처리를 지원하고 있지 않다** → 따라서 처리하기 위해서는 yaml 이라는 써드파티 라이브러리를 설치해야한다.
- yaml 라이브러리의 load() 는 yaml 문자열을 파이썬 데이터로, dump() 는 그 반대의 기능을 수행함
- true, false, on, off 와 같은 값은 부울 형으로 변환되며, 정수와 문자열도 파이썬의 타입으로 변환됨
- PyYAML 은 문자열대신 파이썬 객체를 불러올 수 있으나 위험함, 신뢰할 수 없는 yaml을 불러온다면 load() 대신 safe_load() 를 사용하는 것을 권장 → 그냥 항상 이거 사용해

**8.2.6 보안노트** 

- 객체를 어떤 파일로 저장하고 다시 그 파일을 객체로 읽어오기 위해 이번 장에서 언급한 모든 타입을 사용할 수 있음
- 그러나 이 과정에서 보안 문제가 발생할 수 있음 → 대표적으로 billian laugh 공격의 경우 모든 xml 라이브러리를 뚫어버림
- 이러한 문제를 방지하기 위해 라이브러리의 설정을 변경하거나, defusedxml 라이브러리를 사용할 수 있다.

**8.2.7 설정파일** 

- 대부분의 프로그램은 다양한 옵션이나 설정을 제공, 동적인 것은 프로그램의 인자를 통해 제공하면 되지만, 정적인 것은 어딘가에 유지되어야 함 → 따라서 이러한 '설정값'을 관리해주어야 하는데, 파이썬에서는 표준 모듈로 configparser 모듈을 제공함

**8.2.8 기타 데이터 교환 형식** 

- 다음의 이진 데이터 교환 형식은 일반적으로 더 간결, XML 이나 JSON 보다 빠름
    - MsgPack
    - Protocol Buffers
    - Avro
    - Thrift
- 이들은 이진 형식이기 때문에 텍스트 편집기로 쉽게 편집할 수 없다.

**8.2.9 직렬화하기 : Pickle** 

- 직렬화 : 자료구조(객체) 를 파일로 저장하는 것
- JSON과 같은 형식은 파이썬 프로그램에서 모든 데이터 타입을 직렬화 하는 컨버터가 필요, 파이썬은 바이너리 형식으로 된 객체를 저장하고 복원할 수 있는 pickle 모듈을 제공
- 피클 모듈 사용 시, 원하는 데이터를 자료형의 변경없이 파일로 저장하여 그대로 로드할 수 있으며 피클로 데이터를 저장하거나 불러올때는 파일을 '바이트' 형식으로 읽거나 써야함
    - 모든 파이썬 데이터 객체를 저장, 읽을 수 있음 ㅍ
- 대표 예로,  datetime 을 제이슨으로 인코딩하면 에러가 나는데, 피클 모듈 사용 시 에러 안남
- 피클은 우리가 만든 클래스와 객체에서도 작동함
- pickle.dump() : 직렬화(바이트화) / pickle.load() : 역직렬화
- 피클은 파이썬 객첼ㄹ 만들 수 있기 떄문에 보안문제가 생길 수 있으며 신뢰할 수 없는 것은 역직렬화 하지 않는 것을 추천함

### 8.3 구조화된 이진파일

**8.3.1 스프레드시트** 

- 스프레드시트는 광범위한 이진 데이터 형식, 스프레드시트를 csv 파일로 저장하면 표준 csv모듈을 사용해 이 파일을 읽을 수 있음
- 만약 이진 xls이 있다면 이 파일을 읽고 쓸 수 있는 써드파티 패키지인 xlrd 를 사용하면 됨

**8.3.2 HDF5**

- HDF5(hierachical data format) 은 다차원 혹은 계층적 수치 데이터를 위한 이진 데이터 형식
- 주로 아주 큰 데이터 집합 (기가 ~ 테라) 에 대한 빠른 임의적 접근이 필요한 과학 분야에서 주로 사용
- HDF5 는 쓰기 충돌에 대한 데이터베이스 보호가 필요하지 않은 웜 (write once/read once = 디스크에 데이터를 한번만 쓸 수 있고 그 후에는 데이터가 삭제되지 않도록 보호하는 데이터 저장 기술) 애플리케이션에 적합함

### 8.4 관계형 데이터베이스

- 관계형 데이터베이스는 약 40년된 기술로써 컴퓨팅 세계이 유비쿼터스로 자리잡고 있다.
- 관계형 데이터베이스의 이점은 아래와 같음
    - 다수의 동시 사용자가 데이터에 접근
    - 사용자에 의한 데이터 손상으로부터의 보호
    - 데이터를 저장하고 검색하는 효율적인 방법
    - 스키마에 의해 정의된 데이터와 제약조건에 한정되는 데이터
    - 다양한 데이터 타입과의 관계를 계산하는 조인
    - 서술적인 질의언어 : SQL = structed query language
- 또한 다양한 데이터 간의 관계를 테이블 형태로 표시 → '관계형'
- 각 테이블 내에 유일한 기본키가 존재하며, 기본키에는 인덱싱이 되어있음
- 각 테이블은 상위 데이터베이스 내에 존재

**8.4.1 SQL** 

- sql은 원하는 결과를 질의하는 서술형 언어로, 관계형 데이터 베이스의 보편적인 언어
    - sql 쿼리는 클라이언트에서 데이터 베이스 서버로 전송하는 텍스트 문자열
- sql 에는 두가지 카테고리 존재
    - DDL :  데이터 정의어 : create, drop, use, truncate 등과 같이 테이블, 데이터베이스, 사용자에 대한 생성, 삭제, 제약조건, 권한을 다룸
    - DML : 데이터 조작어 : select, insert, update, delete 와 같이 데이터의 조회,삽입,갱신, 삭제를 다룸

**8.4.2 DB-API** 

- API : application programming interface / 어떤 서비스에 대한 접근을 얻기 위해 호출하는 함수들의 집합
- DB-API : 관계형 데이터베이스에 접근하기 위한 파이썬의 표준 API / 관계형 데이터베이스 각각에 대한 별도의 프로그램을 작성하지 않고 여러 종류의 데이터 베이스를 동작하기 위한 하나의 프로그램만 작성하면 됨
- 메인 함수
    - connect() : 데이터베이스의 연결을 만듦, 이 함수는 사용자 이름, 비번, 서버 주소 등의 인자를 포함
    - cursor() : 질의를 관리하기 위한 커서 객체를 만듦
    - execute(), excutemany() : 데이터 베이스에 하나 이상의 sql 명령을 실행
    - fetchone(), fetchmany() , fetchall() : 실행 결과를 얻음

**8.4.3 SQLite** 

- sqlite 는 가볍고 좋은 오픈소스의 관계형 데이터베이스로, 표준 파이썬 라이브러리로 구현되어있고, 일반 파일처럼 데이터 베이스를 저장
- sqlite 는 간단한 관계형 데이터베이스 애플리케이션에 대한 호환성이 아주 뛰어나며, 다른 애플리케이션에서 sqlite 를 임베디드 데이터베이스처럼 사용할 수 있음
- 사용하거나 생성하고자 하는 로컬 sqlite 데이터베이스 파일을 connect() 로 연결 → 이 파일은 다른 서버에서 테이블을 관리하는 디렉터리 구조와 유사한 데이터 베이스임
- **특수한 문자열인 ':memory:' 는 메모리에서만 데이터베이스를 생성, 빠르고 테스트에 유용하나 프로그램을 종료하거나 컴퓨터를 끄면 데이터가 사라진다.**
- 플레이스 홀더를 사용하면 데이터를 안전하게 넣을 수 있음

        ins = 'insert into zoo(critter,count,damages) values(?,?,?)'
        curs.excute(ins,('weasel',1,2000.0))
        
        # 세 값을 sql 문의 세 물음표에 삽입할 예정이라고 표시한 후, 세 값의 튜플을 excute() 함수 인자로 전달
        # 플레이스 홀더는 웹에서 악의적인 sql 명령을 삽입하는 외부 공격 (sql 인젝션) 으로 부터 시스템을 보호함 

- **sqlite를 떠나기 전, 데이터 베이스 연결과 커서를 열어 이들을 사용한 다음에는 닫아주어야 한다. → curs.close () / conn.close()**

**8.4.4 MySQL** 

- mysql은 매우 인기있는 오픈소스 관계형 데이터베이스로, sqlite와 달리 실제 서버로 사용하며 클라이언트는 네트워크를 통해 mysql 서버에 접근할 수 있다.
- MysqlDB 역시 매우 인기있는 mysql드라이버지만, 아직 파이썬3으로 포팅되지 않았다.
- 파이썬에서 mysql 에 접근하기 위한 드라이버
    - MySQL Connector , PYMySQL, oursql

**8.4.5 PostgreSQL** 

- PostgreSQL 은 완전한 기능을 갖춘 오픈소스 관계형 데이터 베이스로, mysql 보아 사용할 수 있는 고급 기능이 더 많음
- 파이썬에서 postgresql 에 접근하기 위한 드라이버
    - psycopg2 , py-postgresql

**8.4.6 SQLAlchemy** 

- SQL 은 모든 관계형 데이터베이스와 완전히 같지 않다, 그리고 DB-API 는 이를 해소해준다.
    - **sqlalchemy는 파이썬에서 mysql 등의 데이터베이스를 쉽게 사용할 수 있게 해주는 라이브러리**
    - DB-API 는 관계형 데이터베이스 각각을 위한 별도의 프로그램 필요 ㄴㄴ, 하나만 작성하면 됨
- **SQLAlchemy 는 가장 인기있는 크로스 데이터베이스의 파이썬 라이브러리다.**
- 여러가지 수준에서 sqlalchemy 를 사용할 수 있다.
    - 가장 낮은 수준에서 데이터베이스 커넥션 풀을 처리, sql 명령을 실행, 그 결과를 반환 → DB-API와 가장 근접한 위치
        - 커넥션 풀이란, 커넥션을 미리 저장소에 저장한 후, 커넥션 요청 시 마다 저장소에서 꺼내 제공하는 것 , 리소스와 시간을 절약할 수 있음
    - 다음 수준은 SQL 표현언어, 즉 파이써닉한 SQL 빌더
    - 가장 높은 수준은 SQL 표현언어를 사용하고 관계형 자료구조와 애플리케이션 코드를 바인딩하는 ORM (object relational model) 임
- sqlalchemy 는 두가지 카테고리로 나눌 수 있는데,
    - core : 파이썬 코드로 sql 쿼리를 생성하고 실행,
    - ORM : 파이썬 객체를 DB에 저장, DB 에서 다시 파이썬 객체를 READ
- sqlalchemy 사용에 필요한 별도의 드라이버는 없으며, 데이터베이스 드라이버와 함께 작동한다. sqlalchemy 사용 시, 필요한 드라이버를 선택할 수 있는데, 문법은 아래와 같다.
    - dialect + driver // user : password @ host : port / dbname
        - dialect : 데이터 베이스 타입
        - driver : 사용하고자 하는 데이터베이스의 특정 드라이브
        - user & password : 데이터베이스 인증 문자열 (사용자, 비번)
        - host & port : 데이터베이스 서버의 위치
        - dbname : 서버에 연결할 데이터베이스 이름

**SQLAlchemy 수준별 내용 정리 → 자세한건 책을 보세용 (p263~p270)**

- 엔진 : sqlalchemy 에서 db에 접근하려면 db 접속 정보를 알아야 하고, 이런 접속 정보를 받아 연결을 관리하는 객체
- sqlalchemy.create_engine() : DB 접속 주소를 남겨 엔진 생성
1. 가장 낮은 수준 : 엔진 레이어 
    - create_engine : db 접속 정보/ 연결 관리
    - 쿼리 던질 때 sql syntax로 던짐 / db 커넥션 풀 처리
    - 결과는 'Result Proxy'라는  sqlalchemy 객체로 반환된다. → 바로 출력해서 볼 수 없음
    - sqlalchemy의 장점은 코드 앞부분에서 데이터 베이스 드라이버를 임포트하지 않아도 된다는 것, 엔진 문자열에서 데이터 베이스 타입을 알아내며, 이 코드에서 데이터 베이스 타입을 변경하면, 알아서 그 데이터 베이스 타입으로 연결한다.
2. SQL 표현언어 
    - create_engine
    - 표현언어는 엔진레이어보다 더 다양한 sql 문을 처리
    - 쿼리 던질 때, sql 대신 '표현언어' 사용
        - table() : 데이터베이스의 테이블 구조
        - column() : 데이터베이스의 테이블의 열 구조
    - select () = select * from
3. ORM = object relation model
    - sqlalchemy의 최상위 레이어에서 ORM 은 SQL 표현언어를 사용하지만, 실제 데이터 베이스 메커니즘을 숨김 → 관계형 데이터 베이스를 허용하면서, 코드의 객체를 참조, 파이썬 처럼 작동한다. 즉, RDB의 테이블과 컬럼의 관계를 파이썬의 클래스 구조로 변환함
    - 또한 파이썬 객체를 생성, 데이터를 삽입할 수 있음
    - ORM은 주로 간단한 애플리케이션에서 드물게 사용해야 한다. 만일 애플리케이션이 간단하다면 바로 SQL 을 사용 할 수 있다.

### 8.5 NoSQL 데이터 스토어

- 어떤 데이터베이스는 관계형 데이터베이스가 아니며, sql도 지원하지 않는다, 이들은 매우 큰 데이터 집합을 처리하고 데이터 정의에 대해 좀 더 유연하거나 커스텀 데이터 연산을 지원하기 위해 만들어 졌다. → 이들을 뭉뚱그려 NoSQL 이라 부른다.

**8.5.1 dbm 형식** 

- dbm 형식은 nosql이 나타나기 전부터 존재했으며, 키-값 저장 형식으로 파이썬의 딕셔너리와 같다.
    - 키에 값을 할당, 이것은 디스크에 있는 데이터베이스에 자동으로 저장됨
    - 키로부터 값을 얻음
- 키와 값은 바이트로 저장되며, 순회가 불가능하지만 len()을 사용하여 키의 수는 얻을 수 있다.
- get() (특정 키의 값 반환) , setdefault() (딕셔너리에 키와 값 추가)  함수는 딕셔너리에서와 동일하게 동작한다.

**8.5.2 memcached** 

- memcached 는 인메모리 키-값의 캐시 서버로, 주로 데이터베이스 앞단에 놓이거나 웹 서버의 세션 데이터를 저장하는데 사용
- **memcached 란?**
    - 무료로 사용할 수 있는 오픈소스 + 분산 메모리 캐싱 시스템
    - 데이터 베이스의 부하를 줄이고, 속도를 개선하기 위해 사용한다.
    - DB나 API 호출 혹은 렌더링으로 받아오는 결과데이터를 작은 단위의 키-값 형태로 메모리에 저장한다.
    - memcached 는 필요량보다 더 많은 메모리를 가졌을 때, 시스템으로부터 메모리를 사용하고, 필요로 하는 메모리가 부족한 경우 이를 더 쉽게 가져다 사용할 수 있게 해준다.
- 데이터는 지속되지 않아 이전에 쓴 데이터는 사라질 수 있으며 이는 오래된 데이터를 제거, 메모리 부족을 방지한다.
- 사용하기 위해서는 파이썬3의 python-memcached 를 설치하면 된다.

**8.5.3 Redis**

- 레디스는 자료구조 서버, 레디스 서버에 있는 모든 데이터는 memcached 처럼 메모리에 맞아야 한다. (디스크에 데이터를 저장할 수 있는 옵션이 있다. )
- 레디스의 성능은 memcached 에 버금가나, 더 다양한 데이터 구조체를 지원한다.
- 레디스는
    - 서버의 재시작과 신뢰성을 위해 데이터를 디스크에 저장하며
    - 기존 데이터를 유지,
    - 간단한 문자열 이상의 자료구조를 제공한다.
- 레디스 데이터 타입은 파이썬 데이터 타입에 가까우며, 레디스 서버는 여러 파이썬 애플리케이션에서 데이터를 공유하기 위한 중개 역할로 매우 유용하다.
- 레디스를 사용하기 위해서는 redis 를 설치해야 한다.

**레디스란?** 

- 레디스는 단순한 키-값 형태를 띄는데, 단순한 구조로 높은 성능을 보장하며, 저장되는 값이 자료 구조를 가진다. 따라서 다양한 데이터 형을 지원할 수 있다. → 문자열, 셋, 정렬된 셋, 해쉬, 리스트 ,비트 지원
- 지원하는 데이터 형
    1. 문자열 
        - 단일값과 한 키는 레디스 문자열, 간단한 파이썬의 데이터 타입은 자동으로 변환된다.

                conn = redis.Redis() # 레디스 서버 연결 
                #사용 방법 : conn.메서드() 
                set() # 키와 값 할당 ex. conn.set('secret','ni!')
                get() # 키로 값을 얻어옴 
                setnx() #키가 존재하지 않는 경우에만 키에 값을 설정 
                getset() #이전값을 반환, 동시에 새로운 값 설정 
                getrange() # 키의 값의 부분 문자열을 얻어옴 
                setrange() #부분 문자열 교체 
                mset() #한번에 여러 키 설정 
                mget() #한번에 여러 값을 얻음 
                delete() #키 지움 
                incr() , conn.incrbyfloat() # 값 증가 
                decr() # 값 감소 
                # decrbyfloat() 는 없음 

    2. 리스트 
        - 레디스의 리스트는 문자열만  포함할 수 있음, 리스트는 값을 처음 삽입할 때 생성된다.

            # 사용방벙 : conn.메서드(리스트명,값) 
            lpush() # 값삽입 
            linsert() #특정 값 이전 혹은 이후에 값 삽입 
            lset() #오프셋에 값 삽입 (리스트가 존재해야 함) 
            rpush() # 값을 마지막에 삽입 
            lindex() #오프셋의 값을 얻음 
            lrange() #오프셋 범위에 있는 값들을 얻음 
            ltrim() #리스트를 정리, 지정한 오프셋의 범위만 값이 남음 

    3. 해시 
        - 레디스의 해시는 파이썬의 딕셔너리와 비슷하지만 문자열만 포함할 수 있다.
        - 또한 해시는 깊고 중첩된 구조가 아닌 한단계 깊이의 구조를 만든다.
        - 해시는 값 내에 필드 - 문자열 의 쌍으로 이루어진 테이블을 저장하는 데이터 구조체로, 마치 rdbms에서 기본키 한개와 문자열 필드 하나로 이루어진 테이블 같은 것이다.

            hmset(): 해시에서 한개 이상의 필드를 한번에 설정 
            hset() : 해시에서 하나의 필드값을 설정 
            hget() : 하나의 필드값을 얻음 
            hmget() : 하나 이상의 필드값을 얻음 
            hkeys() : 해시의 모든 필드키를 얻음 
            hvals() : 해시의 모든 필드값을 얻음 
            hlen() : 해시 필드의 갯수를 얻음 
            hgetall() : 해시 필드의 모든 키와 값을 얻음 
            hsetnx() : 키가 존재하지 않을 경우 필드와 값 설정 
            

    4. 셋 
        - 레디스의 셋은 파이썬의 셋과 유사

            sadd() : 셋에 하나 이상의 값 추가 
            scard() : 셋에 있는 값의 수 얻음 
            smembers() : 셋의 모든 값을 얻음 
            srem() : 셋에서 값 삭제 
            sinter() : 여러개의 셋 간의 인터섹션(교집합) 을 얻음 
            sinerstore() : 인터섹션값을 얻고 그 값을 다른 셋에 저장함 
            sunion() : 여러개의 셋 간의 유니온 
            sunionstore() : 유니온 한 값을 다른 셋에 저장 
            sdiff() : 여러개의 셋 간의 차집합 
            sdiffstore() : 차집합한 값을 다른 셋에 저장 

    5. 정렬된 셋 
        - 가장 많은 용도로 쓰이는 레디스의 데이터 타입은 정렬된 셋 = zset 이다.
        - 각 값은 연관된 부동 소수점의 스코어를 가짐 → 일종의 가중치로, 이 값에 의해 데이터는 내부적으로 오름차순 정렬된다.
        - 예시는 책 참조 p280
    6. 비트 
        - 비트는 대량의 숫자 집합을 공간 - 효율적인 방식으로 빠르게 처리한다.
        - p281 참조

    **캐시와 만료** 

    - 모든 레디스의 키는 TTL (time to live) 즉, 만료일을 가진다.
    - 만료일을 지정하지 않으면 캐시 데이터가 영구 지속됨
    - 키가 유지되는 시간을 지정하기 위해 expire() 함수를 사용한다.
    - 키 만료는 캐시를 적정 수준으로 유지하고 로그인 세션을 제한하는데 유용하다.

    ### 8.6 풀텍스트 데이터베이스

    - 풀텍스트 검색을 위한 데이터베이스의 특별한 카테고리가 있다.
    - 이는 모든 것을 인덱싱하여 필요한 내용 조회 시, 빠르게 확인될 수 있도록 함
    - 대표적으로 엘라스틱서치가 있음
    - [https://docs.microsoft.com/ko-kr/sql/relational-databases/search/full-text-search?view=sql-server-ver15](https://docs.microsoft.com/ko-kr/sql/relational-databases/search/full-text-search?view=sql-server-ver15)
